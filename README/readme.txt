Однако, столкнулся с необходимостью переписать код под асинхронный формат с
 использованием aiosqlite, 
т.к. в асинхронном боте использовать блокирующие функции не имеет смысла. 
Прошу подсказать, как будет правильнее написать асинхронный код с 
использованием класса для работы с базой данных sqlite. 
И можно ли в данном случае использовать def __init__? 
Я читал что есть какие-то обходные пути с использованием def __init__, 
но я их не до конца понимаю.

Так же хотелось бы избежать вот такого варианта:

async def user_exists(user_id):
"""Есть ли такой пользователь (по id)"""
    async with aiosqlite.connect("db/filedb.db") as db:
        async with db.execute("SELECT EXISTS(SELECT 1 "
                              "FROM users "
                              "WHERE user_id = ?)", (user_id,)) as cursor:
            result1 = await cursor.fetchone()
            result = bool(result1[0])
        return result
Потому что, как мне кажется, если у нас в классе 15 таких методов и 
для каждого метода делать отдельное подключение будет не целесообразным. 
Поправьте меня, если я ошибаюсь, буду рад любым идеям!


Для этого в питоне есть магические методы
 __aenter__ и __aexit__, 
про них можно прочитать например 
тут: https://docs-python.ru/tutorial/sintaksis-async-await-python/asinhronnyj-kontekst-menedzher-async-with/



class DatabaseBot:

    def __init__(self, db_file):
        self.db_file = db_file
        self.lock = asyncio.Lock()

    async def __aenter__(self):
        self.db = await aiosqlite.connect(self.db_file)
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.db.close()


    async def check_user(self, telegram_id: int):
        async with self.lock:
            async with self.db.execute("SELECT telegram_id FROM users WHERE telegram_id = ?", (telegram_id,)) as cursor:
                user_exist = await cursor.fetchone()
                return bool(user_exist)


__aenter__ и __aexit__ позволяют создавать и закрывать соединение 
с базой данных при использовании async with.

Чтобы избежать создания нового соединения для каждого метода, 
вы можете создать один экземпляр DatabaseBot и 
использовать его для всех операций с базой данных внутри 
одной асинхронной функции или корутины.

В этой версии кода используется asyncio.Lock, 
чтобы гарантировать, что только один асинхронный блок 
кода выполняется в базе данных одновременно. 
Это поможет избежать конфликтов при одновременной записи данных.

И еще один момент по поводу блокировок. 
Их использование может привести к увеличению времени выполнения операций, 
если много пользователей пытаются одновременно обратиться к базе данных. 
Тогда придется дорабатывать стратегию блокировок.

А этого можно достичь путем оптимизации кода и уменьшения времени, 
в течение которого блокируется база данных.

Вы можете оптимизировать операции записи, то есть собрать несколько операций 
записи в одну транзакцию, чтобы уменьшить время блокировки базы данных.
Если возможно, внедрите кеширование, 
чтобы уменьшить нагрузку на базу данных, 
особенно если операции чтения преобладают.
Ну или же рассмотрите альтернативные базы данных. 
Если проблемы с производительностью остаются значительными, 
рассмотрите переход к более масштабируемой асинхронной базе данных, 
такой как PostgreSQL с поддержкой асинхронных библиотек.
